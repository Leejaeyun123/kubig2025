# kubig2025

C

1일차(5/19)

소스 파일 = C 언어로 작성한 문서
소스 파일을 컴퓨터가 이해하는 언어인 기계어로 바꾸는 과정은 컴파일
오브젝트 파일(Object File)은 기계어로 작성된 코드로 구성된 파일                 p.33

제어 문자(\n, \t, \b, \r, \a)
\n : 다음 줄로 이동
\t : 다음 탭 위치로 이동 ex) printf("My\tfriend\n"); = My      friend
\b : 한 칸 왼쪽으로 이동 ex) printf("Goot\bd chance\n"); = Good chance
\r : 맨 앞으로 이동 /  \a : 벨소리 ex) printf("Cow\rW\a\n"); = Wow            p.56~59

10진수 : 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
8진수 : 0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17
16진수 : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F
8진수는 숫자 앞에 0(영), 16진수는 0x(영엑스)를 붙여 구분 ex) 12(10진수)      014(8진수)      0xc(16진수)
10진수 -> 16진수 : 십진수를 몫이 0이 될 때까지 16으로 나누고 마지막에 구한 나머지와 처음 구한 나머지를 합침 ex) 30/16 = 몫 : 1, 나머지 : 14 -> 1/16 = 몫 : 0, 나머지 : 1 -> 나머지 : 1,14 -> 1E   printf("%x or %X\n", 30);
10진수 -> 8진수 : 십진수를 몫이 0이 될 때까지 8로 나누고 마지막에 구한 나머지부터 처음 구한 나머지를 합침 ex) 156/8 = 몫 : 19, 나머지 : 4 -> 19/8 = 몫 : 2, 나머지 : 3 -> 2/8 = 몫 : 0, 나머지 : 2 -> 234 printf("%o\n", 156);    
10진수 -> 2진수 : 십진수를 몫이 1이 될 때까지 2로 나누고 마지막에 구한 몫(시작 지점)과 나머지부터 처음 구한 나머지를 합침 ex) 17/2 = 몫 : 8, 나머지 : 1 -> 8/2 = 몫 : 4, 나머지 : 0 -> 4/2 = 몫 : 2, 나머지 : 0 -> 2/2 = 몫 : 1, 나머지 : 0     p.64~67

소수점 앞에 0이 아닌 유효 숫자 한 자리를 사용해 지수 형태로 바꾼 것을 정규화 표기법이라 하고 printf 함수가 실수를 지수 형태로 출력할 때는 기본적으로 정규화 표기법을 사용하고 지수 형태로 출력하려면 %le 변환 문자를 사용 ex) printf("%le\n", 0.0000314); -> 3.140000e-05   p.67~69

1bit(비트) : 2개의 값(0, 1)
1byte(바이트) : bit(비트)가 8개. 2의8승이므로 1byte 값은 256가지.
정수 상수의 양수를 컴파일하면 4바이트 크기의 2진수로 변환 후 빈 공간을 모두 0으로 채움 ex) 정수 13 = 2진수 00000000 00000000 00000000 00001101
                                                                                                        1바이트   2바이트   3바이트  4바이트
정수 상수의 음수는 절댓값을 2의 보수로 컴파일. 2의 보수란 양수를 음수로 표현하는 연산. 2진수의 0과 1을 바꾼 상태(이 상태를 1의 보수라 함)에서 1을 더한 값
ex) -10 ->(절댓값 변환) 10 ->(2진수로 변환) 00000000 00000000 00000000 00001010 ->(0과 1을 바꿈.1의 보수) 11111111 11111111 11111111 11110101 ->(1을 더함) 11111111 11111111 11111111 11110110      p.69~75
2진수 덧셈 규칙 ex) 11110011
                   00000001
                +  11110100 <- 맨 왼쪽부터 1 + 1 = 10 -> 0 쓰고 1 올림, 1 + 0 + (올림 1) = 10 -> 0 쓰고 1 올림, 0 + 0 + (올림 1) = 1 -> 1, 나머지는 그대로 더함

같은 정수형이라도 메모리 저장 공간의 크기에 따라 char(1바이트), short(2바이트), int(4바이트), long(4바이트), long long(8바이트)으로 구분. 저장 가능한 데이터의 범위를 계산하는 공식은 -2의 n(비트 수 -1)승 ~ 2의 n(비트 수 -1)승 -1     p.85

컴파일러는 프로그램에서 사용하는 모든 문자를 0~127 사이의 정수(아스키 코드 값)로 바꾸어 처리하므로 char형 변수를 사용하면 문자를 가장 효과적으로 저장 가능 https://aoworld.tistory.com/25 <- 아스키 코드 표 p.85

특별한 경우가 아니면 정수형을 표현할 때는 int를 사용    p.87
음수가 없는 양수 데이터를 저장할 때는 항상 unsigned를 사용하고 %u로 출력    p.89
실수 자료형은 float, double, long double이 있고 float은 유효 숫자 7자리, double은 15자리 범위 내의 값을 사용 ex) 초깃값 : 1.234567890123456789, float형 출력 : 1.2345678 / double형 출력 : 1.234567890123456    p.89~90
정수형을 기본으로 사용하고 꼭 필요한 경우에만 실수형을 사용, 실수형은 유효 숫자가 많은 double형을 기본으로 사용, long double형은 컴파일러와 버전에 따라 유효 숫자가 다를 수 있음    p.89~90


2일차(5/20)

변수 : 데이터를 저장하는 공간. 값을 바꿀 수 있음
상수 : 한 번 설정한 값을 변경할 수 없음(#define, const로 선언 가능)
변수 선언 ex) int or char or float or ... 변수명;
변수를 선언하면 메모리에 저장 공간이 생김 ex) int a; <- 정수를 넣을 공간으로 int를 사용. 정수를 저장할 공간을 a라 이름 붙여 메모리에 4바이트 할당
변수 초기화 ex) 변수명 = 값;
선언과 동시에 초기화 ex) int or char or float or ... 변수명 = 값;
초기화 된 변수의 값은 가장 마지막에 할당된 값이 최종적으로 적용
ex) 변수명 = 1;
    변수명 = 2;
    변수명 = 3;
        .
        .
        .
    변수명 = 100; <- 최종적으로 적용
변수를 선언하면 메모리에 저장 공간이 생기는데 값을 초기화하지 않으면 저장 공간 안에 쓰레기 값이 생겨서 프로그램에 오류가 생길 수 있음. 그래서 반드시 값을 초기화하는 과정이 필요. 보통 선언과 동시에 초기화를 함 ex) int a = 0; 

문자열은 char형을 배열 형태로 만들어 저장하고 %s로 출력 ex) char fruit(배열명)[6](문자열의 길이+1 이상) = "apple"(문자열);
문자열의 끝에는 항상 /0(널 문자)가 있기 때문에 배열의 크기를 문자열의 길이+1로 잡아야 한다.
영문은 1바이트, 한글은 2바이트 ex) char fruit[20] "영문 or 한글" <- 영문은 최대 19글자, 한글은 최대 9글자
char 배열에 새로운 문자열을 저장할 때 초기화 이외에 strcpy 함수를 사용(string.h 헤더 파일 포함) ex) strcpy(fruit, "banana");    p.91~93

변수를 선언할 때 그 앞에 const를 붙이면 초기화된 값을 바꿀 수 X. 반드시 선언과 동시에 초기화해야 함 ex) const double tax_rate(tax_rate라는 변수를 double형으로 선언) = 0.12(선언과 동시에 0.12로 초기화);
const를 사용하면 변수가 상수처럼 쓰이지만 C 문법이 제공하는 변수의 특성을 모두 가지는 엄연한 변수   p.94~95

변수 선언문에서 자료형 이름은 예약어이고, 변수명은 식별자 ex) int(예약어) age(식별자);
자료형은 단어를 마음대로 바꿀 수 없지만, 변수명은 몇 가지 규칙을 지키고 중복되지 않는다면 어떤 것이든 사용 가능
1. 알파벳 대문자 A~Z, 소문자 a~z, 숫자 0~9, _(밑줄, underline)로 만듦
2. 숫자로 시작 X
3. 대소문자는 서로 다른 식별자로 인식
4. 예약어는 식별자로 사용 X         p.95

scanf 함수는 키보드에서 입력한 값을 변수에 저장할 때 사용 ex) scanf("%d(int형 변환 문자)", &(변수명 앞에 붙임)a(변수명));
문자열을 입력할 때 배열명에 &를 붙이지 않음
ex) char name[20]; <- 이름을 입력할 배열
    scanf("%s", name); <- name 배열에 이름 문자열 입력, &를 사용 X
scanf 함수에서 변환 문자를 정확히 사용해야 함 ex) char형 변수는 정수형으로 그 값을 printf 함수의 %d 변환 문자로 출력 가능하지만 scanf 함수로 입력할 때는 %c 변환 문자를 입력해야 함     p.101~107
문자나 문자열을 입력 받다보면 scanf를 건너뛰는 경우가 있는데 입력 버퍼에 남은 개행 문자(\n) 때문. 즉, char로 입력 받을 수 있음
ex) int a;
    char c;
    scanf("%d", &a); <- 만약 사용자가 5를 입력하고 Enter를 누르면, 버퍼에 5\n이 저장. 5만 읽고, \n은 버퍼에 남김
    scanf("%c", &c); <- 버퍼에 남아있는 \n을 바로 읽고 건너뜀. %c 앞에 공백을 추가(" %c")하면 \n, 공백 등을 무시

피연산자가 1개면 단항, 2개면 이항, 3개면 삼항 연산자 ex) -(단항) 3, 3 +(이항) 5, (3 < 5) ?(삼항) 1 :(삼항) 0        p.112

대입 연산자인 '='은 오른쪽 수식의 결과를 왼쪽 변수에 저장 ex) a = 10;, b = 10;      p.114

나누기 연산자인 '/'은 정수는 몫을 구하고 실수는 소수점까지 구함. 그리고 그 값을 저장하는 변수도 그에 맞게 사용해야 함 
ex) double apple;
    int banana;
    
    apple = 5.0 / 2.0; <- 결과값은 2.5. 연산 결과가 실수이므로 double형 변수에 저장
    banana = 5 / 2; <- 결과값은 2. 연산 결과가 정수이므로 int형 변수에 저장         p.114~115

증감 연산자(++, --)는 전위 표기(++a)가 있고 후위 표기(b++)가 있다. 변수의 값을 1씩 증가시키거나 감소.
ex) int a = 5, b = 5;
    int pre, post;

    pre = (++a) * 3; <- a을 6으로 증가시킨 후 3을 곱함. 16
    post = (b++) * 3; <- b가 증가되기 전에 3을 곱함. 15
전/후위 연산자를 단독으로 쓰면 값이 똑같음
ex) ++a; <- 6
    a++; <- 6        p.117

대소 관계 연산자(<,<=,>,>=)와 동등 관계 연산자(==,!=)의 결과값은 1(true) or 0(false)        p.118~119

논리 연산자에는 &&(and), ||(or), !(not)이 있다. 결과값은 1(true) or 0(false)
ex) (a > 10) && (a < 20);, (a > 10) || (a < 20);, !(a < 20);
숏 서킷 룰이란 좌항만으로 &&와 || 연산 결과를 판별하는 기능. ex) &&는 좌항이 거짓이면 우항과 관계없이 결과는 거짓. ||는 좌항이 참이면 우항과 관계없이 결과가 참         p.120~121


3일차(5/21)

형 변환 연산자는 일시적으로 피연산자의 값을 원하는 형태로 바꾼다.
ex) int a = 10;
    double b = 10.7;
    (double)a = 10.0; <- 정수는 실수로
    (int)b = 10; <- 실수는 정수로
int형을 기본으로 사용하고 실수 연산이 필요할 때 형 변환         p.128~130

sizeof 연산자는 피연산자의 크기를 바이트 단위로 알려 줌으로써 데이터의 크기를 확인하거나 메모리를 동적으로 할당하는 작업 등에 유용. 만약 경고 메시지가 뜬다면 변환 문자를 %zd로 바꾸거나 #pragma warning(disable:4477)을 소스 코드 첫 줄에 추가
ex) int a = 10;
    double b = 3.4;
    printf("int형 변수의 크기 : %d\n", sizeof(a)); <- 결과값 4
    printf("double형 변수의 크기 : %d\n", sizeof(b)); <- 결과값 8
기본적으로 피연산자에 괄호를 사용할 필요는 없지만 편의상 괄호를 사용. 그리고 함수가 아니고 연산자       p.131~133

복합대입 연산자(+=,-=,*=,/=,%=)는 연산 결과를 다시 피연산자에게 저장. 왼쪽 피연산자는 반드시 변수가 와야 함. 오른쪽 항 계산이 모두 끝난 후, 마지막에 복합대입 연산자를 계산
ex) int a = 10, b = 20, res = 2;
    a += 20; <- 결과값 30
    res *= b + 10; <- b + 10 계산 후 res 값을 곱한 후 다시 res에 저장. 결과값 60        p.133~135

콤마 연산자(,)는 대입 연산자보다 우선순위가 낮아서 함께 사용할 때는 반드시 괄호가 필요 ex) res = ++a, ++b; <- res = ++a 연산 후 ++b 연산. 결과값 11         p.135~136

조건(삼항) 연산자(?, :)는 첫 번째 피연산자가 참이면 두 번째 피연산자가 결과값이 되고, 첫 번째 피연산자가 거짓이면 세 번째 피연산자가 결과값
첫 번째 피연산자로는 주로 조건식이 사용됨 ex) (a > b) ? a : b <- 조건식이 참이면 a, 거짓이면 b
조건 연산자의 피연산자에 대입식을 직접 사용 가능 ex) (a > b) ? (res = a) : (res = b);       p.136~138

비트 연산자(&,|,^,>>,<<)는 데이터를 비트로 정확히 표현할 수 있는 정수에만 사용 가능
ex) int a = 10;
    int b = 12;
논리곱 연산(&)은 2개의 피연산자를 각각 비트별로 논리곱 연산해서 두 비트가 모두 1(참)인 경우에만 1로 계산  
printf("a & b : %d\n", a & b);
00000000 00000000 00000000 00001010 a == 10
00000000 00000000 00000000 00001100 b == 12
00000000 00000000 00000000 00001000 a & b == 8 

논리합 연산(|)은 두 비트 중 하나라도 참이면 1(참)로 계산
printf("a | b : %d\n", a | b);
00000000 00000000 00000000 00001010 a == 10
00000000 00000000 00000000 00001100 b == 12
00000000 00000000 00000000 00001110 a | b == 14

배타적 논리합 연산(^)은 두 피연산자의 진리값이 서로 다른 경우에만 1(참)로 계산. 즉, 둘 다 참이거나 둘 다 거짓이면 0(거짓)
printf("a ^ b : %d\n", a ^ b);
00000000 00000000 00000000 00001010 a == 10
00000000 00000000 00000000 00001100 b == 12
00000000 00000000 00000000 00000110 a ^ b == 6

부정 연산자(~)는 피연산자가 하나며, 피연산자의 비트를 반전
printf("~a : %d\n", ~a);
00000000 00000000 00000000 00001010 a == 10
11111111 11111111 11111111 11110101 ~a == -11

비트 이동 연산자(<<,>>)는 왼쪽 or 오른쪽으로 이동
printf("a << 1 : %d\n", a << 1);
이동 전 : 1010(10), 이동 후 : 10100(20, 이동한 만큼 왼쪽으로 밀려나는 비트는 사라지고 오른쪽에 0을 채움)
printf("a >> 2 : %d\n", a >> 2);
이동 전 : 1010(10), 이동 후 : 0010(2, 이동한 만큼 오른쪽으로 밀려나는 비트는 사라지고 왼쪽에 0을 채움). a 값이 양수이면 부호 비트가 0이므로 0을 채우고 음수이면 부호 비트가 1이므로 1을 채움    
비트 연산자를 대입 연산자와 결합해 사용 가능. 단, 부정 연산자(~)는 단항 연산자이므로 사용 불가 ex) a = a << 2; -> a <<= 2;      p.138~141

하나의 수식에서 2개 이상의 연산자가 함께 쓰일 때는 연산자의 우선순위에 따라 연산 ex) 단항 연산자 > 이항 연산자 > 조건(삼항) 연산자
                                                                                산술 연산자 > (비트 이동 연산자) > 관계 연산자 > 논리 연산자
여러 연산자를 함께 사용할 때 의심되거나 분석이 까다롭다고 느껴진다면 주저 없이 괄호를 사용      p.141~145


4일차(5/22)

다양하게 표현된 if문. 아래는 모두 같은 if문
ex) if (a > 10)     if ( a > 10){       if (a > 10)     if (a > 10) b = a;
    {                    b = a;             b = a;
        b = a;      }
    }       p.152
실행할 문장이 두 문장 이상이면 반드시 중괄호({})로 묶어야 함. 묶지 않으면 첫 문장만 if문의 조건식에 따라 실행되며 그 이후의 문장은 조건식과 관계없이 실행
ex) int a = 20;                             
    int b = 0;
    
    1. if  (a < 10)                                
        {
            b = a;                  <- 조건식이 거짓이라 실행 X
            printf("a와 b는 같다."); <- //
        } 

    2. if  (a < 10)                            
    
            b = a;                  <- 조건식이 거짓이라 실행 X
            printf("a와 b는 같다."); <- 조건식과 관계없이 항상 실행         p.152~153

if ~ else문은 두 실행문 중 하나만 실행되며, 반드시 하나는 실행되는 구조이므로 else에는 조건을 사용 X. 실행할 문장이 두 문장 이상이면 반드시 중괄호({})로 묶어야 함
ex) int a = 10;
    
    1. if (a >= 0)
        {
            a = 1;
        }
        else
        {
            a = -1;
        } <- 참이므로 a = 1
    
    2. if (a <= 0)
        {
            a = 1;
        }
        else
        {함
            a = -1;
        } <- 거짓이므로 a = -1      
2개의 실행문 중 하나를 선택하는 경우에는 주저 없이 if ~ else문을 씀
ex) 1.  if  (a >= 0)
        {
            a = 1;
        }
        if  (a < 0)
        {
            a = -1;
        } <- 2개의 if문은 자칫 조건식을 잘못 쓰면 둘 다 실행

    2. if   (a >= 0)
        {
            a = 1;
        }
        else
        {
            a = -1;
        } <- 조건에 따라 실행문 2개 중 하나를 선택해야 할 때는 if ~ else문을 사용
3개 이상의 실행문에서 반드시 하나를 선택하는 경우 if ~ else if ~ else문 사용. 각 조건에 따라 실행할 문장이 두 문장 이상이면 반드시 중괄호로 묶어야 함
ex) int a = 0, b = 0;

    if  (a > 0)
    {
        b = 1;
    } <- 참이면 b = 1을 실행하고 거짓이면 else if로 넘어감
    else if (a == 0)
    {
        b = 2;
    } <- 참이면 b = 2를 실행하고 거짓이면 else로 넘어감
    else
    {
        b = 3;
    } <- else if가 거짓일 경우 b = 3을 반드시 실행          p.152~160
if문 중첩
ex) int a = 20, b = 10;
    
    if  (a > 10)                if  ((a > 10) && (b >= 10))             
    {                           {
        if (b >= 10)                b = 1;
        {                       }
            b = 1;              if  ((a > 10) && (b < 0))
        }               ==      {
        else                        b = -1;
        {                       }
            b = -1;
        }
    }
분할 정복 기법
ex) if  (a == 1)            if (a <= 3)
    {                       {
        printf("일");           if  (a == 1)
    }                           {
    else if (a == 2)                printf("일");
    {                           }
        printf("이");           else if (a == 2)
    }                           {
    else if (a == 3)                printf("이");
    {                           }
        printf("삼");           else
    }                           {
    else if (a == 4)    ==          printf("삼");  
    {                           }
        printf("사");        }      
    }                        else     
    else if (a == 5)         {   
    {                           if  (a == 4)      
        printf("오");           {
    }                               printf("사");  
    else                        }
    {                           else if (a == 5)   
        printf("육");           {                   
    }                               printf("오");   
                                }
                                else
                                {
                                    printf("육");
                                }
                            }
컴파일러는 if문이 중첩된 경우 else를 가장 가까운 if와 연결. 중첩 if문에서 중괄호가 반드시 필요한 이유
ex) int a = 10, b = 20;

    if  (a < 0)                     if  (a < 0)   
    {                               
        if  (b > 0)                     if (b > 0)
        {                               {
            printf("ok");                   printf("ok")
        }                   ->          } 
    }                                   
    else                                else
    {                                   {
        printf("no");                       printf("no");
    } <- "no" 출력                      } <- if (a < 0) 조건문에 중괄호가 없어서 else문은 가장 가까이 있는 if (b > 0) 조건문과 합쳐짐. if (a < 0)이 거짓이므로 출력 X       p.166~171

switch ~ case문은 조건식으로 정수식만 사용. 기본적으로 case는 break를 포함. break는 해당 반복문 또는 switch 블록의 실행을 중단. default는 보통 블록 마지막에 두어 예외 상황을 처리
ex) int rank = 2, m = 0;
    switch (rank)   <- rank = 2
    {
    case 1:         
        m = 300;
        break;
    case 2:         <- case 2로 이동 후 break 이전까지 모든 문장을 실행 후 블록을 탈출
        m = 200;
        break;
    case 3:
        m = 100;
        break;
    default:        <- 만약 rank의 값이 case n:에 해당하는 것이 없으면 default로 이동
        m = 10;
        break;
    }
break는 필요에 따라 생략 가능. 밑에 예시는 break를 전부 생략해서 블록의 끝까지 모든 문장을 실행
ex) switch  (rank) <- rank = 2
    {
    case 1:
        m += 300;
    case 2:         <- case 2로 이동 후 m에 200을 더함
        m += 200;
    case 3:         <- case 2에 break가 없어서 case 3으로 이동 후 100을 더함. += 연산자에 의해 m의 값은 300  
        m += 100;
    }
switch ~ case문을 if문으로 바꾸기
ex) switch  (rank)          if  (rank == 1)
    {                       {
    case 1:                     m = 300;
        m = 300;            }
        break;              else if (rank == 2)
    case 2:                 {
        m = 200;                m = 200;
        break;              }
    case 3:         ->      else if (rank == 3)
        m = 100;            {
        break;                  m = 100;
    default:                }
        m = 10;             else
        break;              {
    }                           m = 10;
                            }           p.172~176


5일차(5/23)

while문에서 실행문이 한 문장이면 중괄호 생략 가능. 두 문장 이상이면 반드시 중괄호 사용. 불필요한 에러를 막기 위해 실행문의 개수와 상관 없이 항상 중괄호로 반복할 부분을 명확히 표시
ex) while (a < 10)
    {
        a *= 2;
        printf("a : %d\n", a);
    } <- a : 2 
         a : 4 
         a : 8 
         a : 16 출력 
    
    while (a < 10)                      while (a < 10)
    a *= 2;                     =       {
    printf("a : %d\n", a);                  a *= 2;
                                        }
                                        printf("a : %d\n", a); <- a : 16 출력   
컴파일러는 반복문의 조건식과 실행문을 모두 한 문장으로 인식. 만약 if문의 실행문이 반복문 하나로 돼 있다면 if문의 중괄호 생략 가능. 명확한 구분을 위해 기본적으로 사용하는 편이 좋음
ex) if (a != 0)                  
        {                                     <- if문의 실행문이 while문 하나이므로 중괄호 생략 가능
            while (a < 10)
            {                                 <- while문의 실행문이 두 문장이므로 중괄호 생략 X
                a *= 2;
                printf("a의 값 : %d\n", a);
            }
        }   <-      p.184~186

for문은 실행문을 반복하는 횟수가 정해져 있을 때 주로 사용       p.186
초기식, 조건식, 증감식은 반복 횟수를 알기 쉽게 작성. 아래는 모두 세 번 반복하는 for문
ex) for (i = 0; i < 3; i++) <- i의 값이 0, 1, 2일 때 세 번 반복     <- 가장 많이 사용하는 형식
    for (i = 2; i <= 4; i++) <- i의 값이 2, 3, 4일 때 세 번 반복
    for (i = 0; i < 7; i += 3) <- i의 값이 0, 3, 6일 때 세 번 반복
    for (i = 3; i > 0; i--) <- i의 값이 3, 2, 1일 때 세 번 반복
for문을 while문으로 바꾸기
ex) for (i = 0; i < 10; i++)                i = 0;
    {                                       while (i < 10)
        printf("Be happy!\n");      ->      {
    }                                           printf("Be happy!\n");
                                                i++;
                                            }       p.188~189
do ~ while문은 일단 반복할 문장을 수행한 후에 조건을 검사. do ~ while문 마지막에 세미콜론(;)을 반드시 씀
ex) int a = 1;
    do                  
    {
        a *= 2;         <- a 값이 1, 2, 4, 8일 때까지 반복 
    } while (a < 10);   <- a 값이 16이 되면 조건식이 거짓이므로 반복을 끝냄
do ~ while문도 반복할 문장이 한 문장이면 중괄호 생략 가능. 기본적으로 사용하는 편이 좋음
ex) do                          
    {
        a *= 2;         ->      do a *= 2; while (a < 10);
    } while (a < 10);
while문은 조건식이 거짓이면 실행문을 한 번도 실행하지 않고 반복문을 빠져나가지만, do ~ while문은 실행문이 조건식 앞에 있으므로 실행문을 최소 한 번은 실행       p.188~191


6일차(5/24)

반복문 중간에서 임의로 반복을 끝내고 싶을 때는 break를 사용
ex) int i;
    int sum = 0;

    for (i = 1; i <= 10; i++)
    {
        sum += i;
        if  (sum > 30) break; <- 누적한 값이 30보다 크면 반복문을 끝냄
    }
break는 자신을 포함한 반복문 하나만 벗어난다.
ex) 1. while( ... )
        {
            for( ... )
            {
                ...
                if (조건식) break; <- 안쪽 for문 하나만 탈출
            }                                           ↓
                                                        ← 이동
        }
    2. while (조건식)
       {
            ...
            if (조건식)
            {
                ...
                break; <- 반복문 블록 전체를 벗어남
            }                                 ↓
       }                                      ↓
                                              ← 이동
반복문의 조건식이 항상 참이면 무한 반복문이 됨
ex) 1. while (n)
       {
            printf("Be happy!\n");
       } <- 조건식에 0을 제외한 숫자를 넣으면 출력문은 무한 반복
    
    2. for (;;)
        {
            printf("Be happy!\n);    
        } <- for문은 괄호 안에 ;; 사용      p.199~201

continue는 반복문의 일부를 건너뜀. 반복문 안에서 continue를 사용하면 다음 실행 위치가 반복문의 블록 끝이 되는데 블록을 탈출하는 것은 아님
ex) int i, sum = 0;
    for (i = 1; i <= 100; i++)
    {
        if  ( (i % 3) == 0)
        {
            continue; →→→→→→
        }                        ↓
        sum += i;                ↓
    } ←←←←←←←←←←←←←← (i % 3) == 0 조건을 충족하면 sum += i;를 건너뛰고 블록 끝으로 간 후 다시 반복
while문에서 continue를 사용했을 시
ex) i = 1;
    while (i <= 100)
    {
        if  ((i % 3) == 0)
        {
            continue; →→→→→→
        }                        ↓
        sum += i;                ↓
        i++;                     ↓
    } ←←←←←←←←←←←←←← (i % 3) == 0 조건을 충족하면 i++;을 건너뛰므로 조건식은 계속 참이 돼서 무한 반복       p.202


복습(5/25)


8일차(5/26)

함수는 기능을 수행하는 코드 단위. ex) main, printf, scanf,...
printf나 scanf 함수처럼 특정 기능을 미리 약속하고 프로그램에서 바로 사용할 수 있게 구현되어 있는 함수를 표준 라이브러리 함수라고 함
함수를 만들 때 중요한 3가지
1. 함수 정의 : 함수를 실제 코드로 만드는 것으로 함수의 기능을 구현
2. 함수 호출 : 함수 호출을 해야지 함수를 사용 가능
3. 함수 선언 : 프로그램의 상단에서 어떤 함수를 사용할 것이라고 컴파일러에게 정보를 주는 역할        p.208

함수 정의 전 생각할 3가지
1. 함수의 기능에 맞는 이름은 무엇인가? -> 구현하려는 기능 = 더하기 = 영어로는 sum(함수명)
2. 함수가 기능을 수행하는 데 필요한 데이터는 무엇인가? -> 더하려는 정수 2개(매개변수)
3. 함수가 수행된 후의 결과는 무엇인가? -> 정수(반환형)
ex ) 반환형 함수명(매개변수1, 매개변수2) <- 함수 원형
     {
         // 함수가 수행하는 명령, 결과값(매개변수1+매개변수2)을 돌려보냄
     } <- 중괄호 안에 함수가 수행할 내용을 넣어 주면 함수가 완성되고 이것을 함수 정의라고 함
두 수를 더하는 함수를 만들고 사용하는 방법
ex) int sum(int x, int y);      <- sum 함수 선언

    int main(void)              <- main 함수 시작
    {
        int a = 10, b = 20;
        int result;             <- 두 정수를 더한 결과(result)를 저장할 변수

        result = sum(a, b);     <- sum 함수 호출
        printf("result : %d\n", result);

        return 0;
    }                           <- main 함수의 끝

    int sum(int x, int y)       <- sum 함수 정의 시작
    {
        int temp;               <- 두 정수의 합을 잠시 저장할 변수

        temp = x + y;           <- x와 y의 합을 temp에 보관

        return temp;            <- temp의 값을 반환
    }                           <- sum 함수의 끝. 실행결과는 30         p.209~211

함수를 만들고 사용하려면 호출을 해야 하고 호출할 때에는 이름을 사용하며 함수에 필요한 데이터를 괄호 안에 넣어 주는데, 이를 '인수'라 함. 인수는 상수나 변수를 쓸 수 있음
ex) result = sum(a, b); <- 함수명(sum)과 함께 괄호 안에 a, b(인수)를 넣고 호출
    result = sum(a*2, b/3); <- 수식을 사용하면 수식의 결과값이 인수로 쓰임
함수 호출에 입력된 인수는 호출된 함수의 매개변수(int x, int y)에 복사되어 사용. sum 함수 호출 -> main 함수 실행을 잠시 멈춤 -> sum 함수 정의 부분에 있는 코드 실행
ex) int main(void)
    {
        ...
        result = sum(a, b); -> sum 함수 호출 -> int sum(int x, int y) -> 인수 a, b 값은 매개변수 x, y로 복사 후 실행 
        ...                                    {
    }                                               ...
                                               }        p.212~213

호출된 함수의 실행이 끝나고 호출한 곳으로 값을 반환할 때 return문을 사용
ex) int sum(int x, int y)                                           int main(void)       
    {                                                               {
        int temp;                                                       ...
        temp = x + y;                                   ->              result = sum(a, b); <- main 함수는 반환된 값을 result에 저장하고 잠시 중단했던 함수의 나머지 부분을 실행 
        return temp; <- temp 값을 sum(a, b);에 반환                      ...
    }                                                               }    
함수의 반환값을 수식의 일부로 사용할 수 있다.
ex) result = sum(a, b) * 2; <- 순서는 함수 호출(1) -> 곱셈(2) -> 대입(3)        p.213~214
       3         1       2

함수 선언은 컴파일러가 새로 만든 함수를 인식할 수 있도록 알리는 역할. 선언 방법은 함수 원형에 세미콜론 붙이기
ex) int sum(int, int); <- main 함수 앞에 선언하며 매개변수 이름은 생략 가능
main 함수 앞에 sum 함수를 정의하면 함수 정의에 원형이 포함되므로 따로 함수 선언 X. 프로그램은 항상 main 함수부터 시작하며 그 이후에는 호출된 순서에 따라 실행.
ex) int sum(int x, int y)       
    {
        ...                     4(sum 함수 실행)
        return temp;            5(sum 함수 반환)
    }

    int main(void)              1(main 함수 시작)
    {                           2(main 함수 실행)
        result = sum(a, b);     3(sum 함수 호출)
        ...                     6(나머지 main 함수 실행)
        return 0;
    }
함수 선언이 없으면 함수 정의는 항상 함수 호출 이전에 있어야 함. 웬만하면 필요한 함수를 main 함수 밑에 차례로 만들고 main 함수 앞에는 모든 함수를 선언하는 편이 좋음         p.214~215


9일차(5/27)

x


10일차(5/28)

x


11일차(5/29)

x


12일차(5/30)

x


13일차(5/31)

x


14일차(6/1)

x


15일차(6/2)

x


16일차(6/3)

x


17일차(6/4)

x


18일차(6/5)


