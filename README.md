# kubig2025

C

1일차

소스 파일 = C 언어로 작성한 문서
소스 파일을 컴퓨터가 이해하는 언어인 기계어로 바꾸는 과정은 컴파일
오브젝트 파일(Object File)은 기계어로 작성된 코드로 구성된 파일     p.33

제어 문자(\n, \t, \b, \r, \a)
\n : 다음 줄로 이동
\t : 다음 탭 위치로 이동 ex) printf("My\tfriend\n"); = My      friend
\b : 한 칸 왼쪽으로 이동 ex) printf("Goot\bd chance\n"); = Good chance
\r : 맨 앞으로 이동 /  \a : 벨소리 ex) printf("Cow\rW\a\n"); = Wow      p.56~59

10진수 : 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
8진수 : 0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17
16진수 : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F
8진수는 숫자 앞에 0(영), 16진수는 0x(영엑스)를 붙여 구분 ex) 12(10진수)      014(8진수)      0xc(16진수)
10진수 -> 16진수 : 십진수를 몫이 0이 될 때까지 16으로 나누고 마지막에 구한 나머지와 처음 구한 나머지를 합침 ex) 30/16 = 몫 : 1, 나머지 : 14 -> 1/16 = 몫 : 0, 나머지 : 1 -> 나머지 : 1,14 -> 1E   printf("%x or %X\n", 30);
10진수 -> 8진수 : 십진수를 몫이 0이 될 때까지 8로 나누고 마지막에 구한 나머지부터 처음 구한 나머지를 합침 ex) 156/8 = 몫 : 19, 나머지 : 4 -> 19/8 = 몫 : 2, 나머지 : 3 -> 2/8 = 몫 : 0, 나머지 : 2 -> 234 printf("%o\n", 156);    
10진수 -> 2진수 : 십진수를 몫이 1이 될 때까지 2로 나누고 마지막에 구한 몫(시작 지점)과 나머지부터 처음 구한 나머지를 합침 ex) 17/2 = 몫 : 8, 나머지 : 1 -> 8/2 = 몫 : 4, 나머지 : 0 -> 4/2 = 몫 : 2, 나머지 : 0 -> 2/2 = 몫 : 1, 나머지 : 0     p.64~67

소수점 앞에 0이 아닌 유효 숫자 한 자리를 사용해 지수 형태로 바꾼 것을 정규화 표기법이라 하고 printf 함수가 실수를 지수 형태로 출력할 때는 기본적으로 정규화 표기법을 사용하고 지수 형태로 출력하려면 %le 변환 문자를 사용 ex) printf("%le\n", 0.0000314); -> 3.140000e-05   p.67~69

1bit(비트) : 2개의 값(0, 1)
1byte(바이트) : bit(비트)가 8개. 2의8승이므로 1byte 값은 256가지.
정수 상수의 양수를 컴파일하면 4바이트 크기의 2진수로 변환 후 빈 공간을 모두 0으로 채움 ex) 정수 13 = 2진수 00000000 00000000 00000000 00001101
                                                                                                        1바이트   2바이트   3바이트  4바이트
정수 상수의 음수는 절댓값을 2의 보수로 컴파일. 2의 보수란 2진수의 0과 1을 바꾼 상태(이 상태를 1의 보수라 함)에서 1을 더한 값
ex) -10 ->(절댓값 변환) 10 ->(2진수로 변환) 00000000 00000000 00000000 00001010 ->(0과 1을 바꿈.1의 보수) 11111111 11111111 11111111 11110101 ->(1을 더함) 11111111 11111111 11111111 11110110  p.69~75

같은 정수형이라도 메모리 저장 공간의 크기에 따라 char(1바이트), short(2바이트), int(4바이트), long(4바이트), long long(8바이트)으로 구분. 저장 가능한 데이터의 범위를 계산하는 공식은 -2의 n(비트 수 -1)승 ~ 2의 n(비트 수 -1)승 -1 p.85

컴파일러는 프로그램에서 사용하는 모든 문자를 0~127 사이의 정수(아스키 코드 값)로 바꾸어 처리하므로 char형 변수를 사용하면 문자를 가장 효과적으로 저장 가능 https://aoworld.tistory.com/25 <- 아스키 코드 표 p.85

특별한 경우가 아니면 정수형을 표현할 때는 int를 사용    p.87
음수가 없는 양수 데이터를 저장할 때는 항상 unsigned를 사용하고 %u로 출력    p.89
실수 자료형은 float, double, long double이 있고 float는 유효 숫자 7자리, double은 15자리 범위 내의 값을 사용 ex) 초깃값 : 1.234567890123456789, float형 출력 : 1.2345678 / double형 출력 : 1.234567890123456    p.89~90
정수형을 기본으로 사용하고 꼭 필요한 경우에만 실수형을 사용, 실수형은 유효 숫자가 많은 double형을 기본으로 사용, long double형은 컴파일러와 버전에 따라 유효 숫자가 다를 수 있음    p.89~90


2일차

변수 : 값을 바꿀 수 있음
상수 : 한 번 설정한 값을 변경할 수 없음(#define, const로 선언 가능)
변수 선언 ex) int or char or float or ... 변수명;
변수를 선언하면 메모리에 저장 공간이 생김 ex) int a; <- 정수를 넣을 공간으로 int를 사용. 정수를 저장할 공간을 a라 이름 붙여 메모리에 4바이트 할당
변수 초기화 ex) 변수명 = 값;
선언과 동시에 초기화 ex) int or char or float or ... 변수명 = 값;
초기화 된 변수의 값은 가장 마지막에 할당된 값이 최종적으로 적용
ex) 변수명 = 1;
    변수명 = 2;
    변수명 = 3;
        .
        .
        .
    변수명 = 100; <- 최종적으로 적용

문자열은 char형을 배열 형태로 만들어 저장하고 %s로 출력 ex) char fruit(배열명)[6](문자열의 길이+1 이상) = "apple"(문자열);
문자열의 끝에는 항상 /0(널 문자)가 있기 때문에 배열의 크기를 문자열의 길이+1로 잡아야 한다.
영문은 1바이트, 한글은 2바이트 ex) char fruit[20] "영문 or 한글" <- 영문은 최대 19글자, 한글은 최대 9글자
char 배열에 새로운 문자열을 저장할 때 초기화 이외에 strcpy 함수를 사용(string.h 헤더 파일 포함) ex) strcpy(fruit, "banana");    p.91~93

변수를 선언할 때 그 앞에 const를 붙이면 초기화된 값을 바꿀 수 X. 반드시 선언과 동시에 초기화해야 함 ex) const double tax_rate(tax_rate라는 변수를 double형으로 선언) = 0.12(선언과 동시에 0.12로 초기화);
const를 사용하면 변수가 상수처럼 쓰이지만 C 문법이 제공하는 변수의 특성을 모두 가지는 엄연한 변수   p.94~95

변수 선언문에서 자료형 이름은 예약어이고, 변수명은 식별자 ex) int(예약어) age(식별자);
자료형은 단어를 마음대로 바꿀 수 없지만, 변수명은 몇 가지 규칙을 지키고 중복되지 않는다면 어떤 것이든 사용 가능
1. 알파벳 대문자 A~Z, 소문자 a~z, 숫자 0~9, _(밑줄, underline)로 만듦
2. 숫자로 시작 X
3. 대소문자는 서로 다른 식별자로 인식
4. 예약어는 식별자로 사용 X     p.95

scanf 함수는 키보드에서 입력한 값을 변수에 저장할 때 사용 ex) scanf("%d(int형 변환 문자)", &(변수명 앞에 붙임)a(변수명));
문자열을 입력할 때 배열명에 &를 붙이지 않음
ex) char name[20]; <- 이름을 입력할 배열
    scanf("%s", name); <- name 배열에 이름 문자열 입력, &를 사용 X
scanf 함수에서 변환 문자를 정확히 사용해야 함 ex) char형 변수는 정수형으로 그 값을 printf 함수의 %d 변환 문자로 출력 가능하지만 scanf 함수로 입력할 때는 %c 변환 문자를 입력해야 함     p.101~107

피연산자가 1개면 단항, 2개면 이항, 3개면 삼항 연산자 ex) -(단항) 3, 3 +(이항) 5, (3 < 5) ?(삼항) 1 :(삼항) 0

대입 연산자인 '='은 오른쪽 수식의 결과를 왼쪽 변수에 저장 ex) a=10;, b=10;


나누기 연산자인 '/'은 정수는 몫을 구하고 실수는 소수점까지 구함. 그리고 그 값을 저장하는 변수도 그에 맞게 사용해야 함 
ex) double apple;
    int banana;
    
    apple = 5.0 / 2.0; <- 결과값은 2.5. 연산 결과가 실수이므로 double형 변수에 저장
    banana = 5 / 2; <- 결과값은 2. 연산 결과가 정수이므로 int형 변수에 저장

증감 연산자(++, --)는 전위 표기(++a)가 있고 후위 표기(b++)가 있다. 변수의 값을 1씩 증가시키거나 감소
ex) int a = 5, b = 5;
    int pre, post;

    pre = (++a) * 3; <- a을 6으로 증가시킨 후 3을 곱함. 16
    post = (b++) * 3; <- b가 증가되기 전에 3을 곱함. 15

대소 관계 연산자(<,<=,>,>=)와 동등 관계 연산자(==,!=)의 결과값은 1(true) or 0(false)

논리 연산자에는 &&(and), ||(or), !(not)이 있다. 결과값은 1(true) or 0(false) ~ p.127


3일차

형 변환 연산자는 일시적으로 피연산자의 값을 원하는 형태로 바꾼다.
ex) int a = 10;
    double b = 10.7;
    (double)a = 10.0; <- 정수는 실수로
    (int)b = 10; <- 실수는 정수로
int형을 기본으로 사용하고 실수 연산이 필요할 때 형 변환     p.128~130

sizeof 연산자는 피연산자의 크기를 바이트 단위로 알려 줌으로써 데이터의 크기를 확인하거나 메모리를 동적으로 할당하는 작업 등에 유용. 만약 경고 메시지가 뜬다면 변환 문자를 %zd로 바꾸거나 #pragma warning(disable:4477)을 소스 코드 첫 줄에 추가
ex) int a = 10;
    double b = 3.4;
    printf("int형 변수의 크기 : %d\n", sizeof(a)); <- 결과값 4
    printf("double형 변수의 크기 : %d\n", sizeof(b)); <- 결과값 8
기본적으로 피연산자에 괄호를 사용할 필요는 없지만 편의상 괄호를 사용. 그리고 함수가 아니고 연산자   p.131~133

복합대입 연산자(+=,-=,*=,/=,%=)는 연산 결과를 다시 피연산자에게 저장. 왼쪽 피연산자는 반드시 변수가 와야 함. 오른쪽 항 계산이 모두 끝난 후, 마지막에 복합대입 연산자를 계산
ex) int a = 10, b = 20, res = 2;
    a += 20; <- 결과값 30
    res *= b + 10; <- b + 10 계산 후 res 값을 곱한 후 다시 res에 저장. 결과값 60    p.133~135

콤마 연산자(,)는 대입 연산자보다 우선순위가 낮아서 함께 사용할 때는 반드시 괄호가 필요 ex) res = ++a, ++b; <- res = ++a 연산 후 ++b 연산. 결과값 11     p.135~136

조건(삼항) 연산자(?, :)는 첫 번째 피연산자가 참이면 두 번째 피연산자가 결과값이 되고, 첫 번째 피연산자가 거짓이면 세 번째 피연산자가 결과값
첫 번째 피연산자로는 주로 조건식이 사용됨 ex) (a > b) ? a : b <- 조건식이 참이면 a, 거짓이면 b
조건 연산자의 피연산자에 대입식을 직접 사용 가능 ex) (a > b) ? (res = a) : (res = b);   p.136~138

비트 연산자(&,|,^,>>,<<)는 데이터를 비트로 정확히 표현할 수 있는 정수에만 사용 가능
ex) int a = 10;
    int b = 12;
논리곱 연산(&)은 2개의 피연산자를 각각 비트별로 논리곱 연산해서 두 비트가 모두 1(참)인 경우에만 1로 계산  
printf("a & b : %d\n", a & b);
00000000 00000000 00000000 00001010 a == 10
00000000 00000000 00000000 00001100 b == 12
00000000 00000000 00000000 00001000 a & b == 8 

논리합 연산(|)은 두 비트 중 하나라도 참이면 1(참)로 계산
printf("a | b : %d\n", a | b);
00000000 00000000 00000000 00001010 a == 10
00000000 00000000 00000000 00001100 b == 12
00000000 00000000 00000000 00001110 a | b == 14

배타적 논리합 연산(^)은 두 피연산자의 진리값이 서로 다른 경우에만 1(참)로 계산. 즉, 둘 다 참이거나 둘 다 거짓이면 0(거짓)
printf("a ^ b : %d\n", a ^ b);
00000000 00000000 00000000 00001010 a == 10
00000000 00000000 00000000 00001100 b == 12
00000000 00000000 00000000 00000110 a ^ b == 6

부정 연산자(~)는 피연산자가 하나며, 피연산자의 비트를 반전
printf("~a : %d\n", ~a);
00000000 00000000 00000000 00001010 a == 10
11111111 11111111 11111111 11110101 ~a == -11

비트 이동 연산자(<<,>>)는 왼쪽 or 오른쪽으로 이동
printf("a << 1 : %d\n", a << 1);
이동 전 : 1010(10), 이동 후 : 10100(20, 이동한 만큼 왼쪽으로 밀려나는 비트는 사라지고 오른쪽에 0을 채움)
printf("a >> 2 : %d\n", a >> 2);
이동 전 : 1010(10), 이동 후 : 0010(2, 이동한 만큼 오른쪽으로 밀려나는 비트는 사라지고 왼쪽에 0을 채움). a 값이 양수이면 부호 비트가 0이므로 0을 채우고 음수이면 부호 비트가 1이므로 1을 채움    
비트 연산자를 대입 연산자와 결합해 사용 가능. 단, 부정 연산자(~)는 단항 연산자이므로 사용 불가 ex) a = a << 2; -> a <<= 2;   p.138~141

하나의 수식에서 2개 이상의 연산자가 함께 쓰일 때는 연산자의 우선순위에 따라 연산 ex) 단항 연산자 > 이항 연산자 > 조건(삼항) 연산자
                                                                                산술 연산자 > (비트 이동 연산자) > 관계 연산자 > 논리 연산자
여러 연산자를 함께 사용할 때 의심되거나 분석이 까다롭다고 느껴진다면 주저 없이 괄호를 사용  p.141~145


4일차

다양하게 표현된 if문. 아래는 모두 같은 if문
ex) if (a > 10)     if ( a > 10){       if (a > 10)     if (a > 10) b = a;
    {                    b = a;             b = a;
        b = a;      }
    }   p.152
실행할 문장이 두 문장 이상이면 반드시 중괄호({})로 묶어야 함. 묶지 않으면 첫 문장만 if문의 조건식에 따라 실행되며 그 이후의 문장은 조건식과 관계없이 실행
ex) int a = 20;                             
    int b = 0;
    
    1. if  (a < 10)                                
        {
            b = a;                  <- 조건식이 거짓이라 실행 X
            printf("a와 b는 같다."); <- //
        } 

    2. if  (a < 10)                            
    
            b = a;                  <- 조건식이 거짓이라 실행 X
            printf("a와 b는 같다."); <- 조건식과 관계없이 항상 실행     p.152~153

if ~ else문은 두 실행문 중 하나만 실행되며, 반드시 하나는 실행되는 구조이므로 else에는 조건을 사용 X. 실행할 문장이 두 문장 이상이면 반드시 중괄호({})로 묶어야 함
ex) int a = 10;
    
    1. if (a >= 0)
        {
            a = 1;
        }
        else
        {
            a = -1;
        } <- 참이므로 a = 1
    
    2. if (a <= 0)
        {
            a = 1;
        }
        else
        {함
            a = -1;
        } <- 거짓이므로 a = -1      
2개의 실행문 중 하나를 선택하는 경우에는 주저 없이 if ~ else문을 씀
ex) 1.  if  (a >= 0)
        {
            a = 1;
        }
        if  (a < 0)
        {
            a = -1;
        } <- 2개의 if문은 자칫 조건식을 잘못 쓰면 둘 다 실행

    2. if   (a >= 0)
        {
            a = 1;
        }
        else
        {
            a = -1;
        } <- 조건에 따라 실행문 2개 중 하나를 선택해야 할 때는 if ~ else문을 사용
3개 이상의 실행문에서 반드시 하나를 선택하는 경우 if ~ else if ~ else문 사용
ex) int a = 0, b = 0;

    if  (a > 0)
    {
        b = 1;
    } <- 참이면 b = 1을 실행하고 거짓이면 else if로 넘어감
    else if (a == 0)
    {
        b = 2;
    } <- 참이면 b = 2를 실행하고 거짓이면 else로 넘어감
    else
    {
        b = 3;
    } <- else if가 거짓일 경우 b = 3을 반드시 실행














