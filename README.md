# kubig2025

C

1일차

소스 파일 = C 언어로 작성한 문서
소스 파일을 컴퓨터가 이해하는 언어인 기계어로 바꾸는 과정은 컴파일
오브젝트 파일(Object File)은 기계어로 작성된 코드로 구성된 파일

제어 문자(\n, \t, \b, \r, \a)
\n : 다음 줄로 이동
\t : 다음 탭 위치로 이동 ex) printf("My\tfriend\n"); = My      friend
\b : 한 칸 왼쪽으로 이동 ex) printf("Goot\bd chance\n"); = Good chance
\r : 맨 앞으로 이동 /  \a : 벨소리 ex) printf("Cow\rW\a\n"); = Wow

10진수 : 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
8진수 : 0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17
16진수 : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F
8진수는 숫자 앞에 0(영), 16진수는 0x(영엑스)를 붙여 구분 ex) 12(10진수)      014(8진수)      0xc(16진수) 

소수점 앞에 0이 아닌 유효 숫자 한 자리를 사용해 지수 형태로 바꾼 것을 정규화 표기법이라 하고 printf 함수가 실수를 지수 형태로 출력할 때는 기본적으로 정규화 표기법을 사용 ex) 0.0000314(소수점 형태) = 3.14e-5(정규화)

1bit(비트) : 2개의 값(0, 1)
1byte(바이트) : bit(비트)가 8개. 2의8승이므로 1byte 값은 256가지.
정수 상수의 양수를 컴파일하면 4바이트 크기의 2진수로 변환 후 빈 공간을 모두 0으로 채움 ex) 정수 13 = 2진수 00000000 00000000 00000000 00001101
                                                                                                        1바이트   2바이트   3바이트  4바이트
정수 상수의 음수는 절댓값을 2의 보수로 컴파일. 2의 보수란 2진수의 0과 1을 바꾼 상태(이 상태를 1의 보수라 함)에서 1을 더한 값
ex) -10 ->(절댓값 변환) 10 ->(2진수로 변환) 00000000 00000000 00000000 00001010 ->(0과 1을 바꿈.1의 보수) 11111111 11111111 11111111 11110101 ->(1을 더함) 11111111 11111111 11111111 11110110

같은 정수형이라도 메모리 저장 공간의 크기에 따라 char(1바이트), short(2바이트), int(4바이트), long(4바이트), long long(8바이트)으로 구분. 저장 가능한 데이터의 범위를 계산하는 공식은 -2의 n(비트 수 -1)승 ~ 2의 n(비트 수 -1)승 -1

컴파일러는 프로그램에서 사용하는 모든 문자를 0~127 사이의 정수(아스키 코드 값)로 바꾸어 처리하므로 char형 변수를 사용하면 문자를 가장 효과적으로 저장 가능 https://aoworld.tistory.com/25 <- 아스키 코드 표

특별한 경우가 아니면 정수형을 표현할 때는 int를 사용
음수가 없는 양수 데이터를 저장할 때는 항상 unsigned를 사용하고 %u로 출력
실수 자료형은 float, double, long double이 있고 float는 유효 숫자 7자리, double은 15자리 범위 내의 값을 사용 ex) 초깃값 : 1.234567890123456789, float형 출력 : 1.2345678 / double형 출력 : 1.234567890123456
정수형을 기본으로 사용하고 꼭 필요한 경우에만 실수형을 사용, 실수형은 유효 숫자가 많은 double형을 기본으로 사용, long double형은 컴파일러와 버전에 따라 유효 숫자가 다를 수 있음 ~ p.90


2일차

변수 : 값을 바꿀 수 있음
상수 : 한 번 설정한 값을 변경할 수 없음(#define, const로 선언 가능)
변수 선언 ex) int or char or float or ... 변수명;
변수 초기화 ex) 변수명 = 값;
선언과 동시에 초기화 ex) int or char or float or ... 변수명 = 값;
초기화 된 변수의 값은 가장 마지막에 할당된 값이 최종적으로 적용
ex) 변수명 = 1;
    변수명 = 2;
    변수명 = 3;
        .
        .
        .
    변수명 = 100; <- 최종적으로 적용

문자열은 char형을 배열 형태로 만들어 저장하고 %s로 출력 ex) char fruit(배열명)[6](문자열의 길이+1 이상) = "apple"(문자열);
char 배열에 새로운 문자열을 저장할 때 초기화 이외에 strcpy 함수를 사용(string.h 헤더 파일 포함) ex) strcpy(fruit, "banana");

변수를 선언할 때 그 앞에 const를 붙이면 초기화된 값을 바꿀 수 X. 반드시 선언과 동시에 초기화해야 함 ex) const double tax_rate(tax_rate라는 변수를 double형으로 선언) = 0.12(선언과 동시에 0.12로 초기화);
const를 사용하면 변수가 상수처럼 쓰이지만 C 문법이 제공하는 변수의 특성을 모두 가지는 엄연한 변수

변수 선언문에서 자료형 이름은 예약어이고, 변수명은 식별자 ex) int(예약어) age(식별자);
자료형은 단어를 마음대로 바꿀 수 없지만, 변수명은 몇 가지 규칙을 지키고 중복되지 않는다면 어떤 것이든 사용 가능
1. 알파벳 대문자 A~Z, 소문자 a~z, 숫자 0~9, _(밑줄, underline)로 만듦
2. 숫자로 시작 X
3. 대소문자는 서로 다른 식별자로 인식
4. 예약어는 식별자로 사용 X

scanf 함수는 키보드에서 입력한 값을 변수에 저장할 때 사용 ex) scanf("%d(int형 변환 문자)", &(변수명 앞에 붙임)a(변수명));
문자열을 입력할 때 배열명에 &를 붙이지 않음
ex) char name[20]; <- 이름을 입력할 배열
    scanf("%s", name); <- name 배열에 이름 문자열 입력, &를 사용 X
scanf 함수에서 변환 문자를 정확히 사용해야 함 ex) char형 변수는 정수형으로 그 값을 printf 함수의 %d 변환 문자로 출력 가능하지만 scanf 함수로 입력할 때는 %c 변환 문자를 입력해야 함


나누기 연산자인 '/'은 정수는 몫을 구하고 실수는 소수점까지 구함. 그리고 그 값을 저장하는 변수도 그에 맞게 사용해야 함 
ex) double apple;
    int banana;
    
    apple = 5.0 / 2.0; <- 결과값은 2.5. 연산 결과가 실수이므로 double형 변수에 저장
    banana = 5 / 2; <- 결과값은 2. 연산 결과가 정수이므로 int형 변수에 저장

증감 연산자(++, --)는 전위 표기(++a)가 있고 후위 표기(b++)가 있다. 변수의 값을 1씩 증가시키거나 감소
ex) int a = 5, b = 5;
    int pre, post;

    pre = (++a) * 3; <- a을 6으로 증가시킨 후 3을 곱함. 16
    post = (b++) * 3; <- b가 증가되기 전에 3을 곱함. 15

대소 관계 연산자(<,<=,>,>=)와 동등 관계 연산자(==,!=)의 결과값은 1(true) or 0(false)

논리 연산자에는 &&(and), ||(or), !(not)이 있다. 결과값은 1(true) or 0(false) ~ p.127


3일차

형 변환 연산자는 일시적으로 피연산자의 값을 원하는 형태로 바꾼다.
ex) int a = 10;
    double b = 10.7;
    (double)a = 10.0; <- 정수는 실수로
    (int)b = 10; <- 실수는 정수로
int형을 기본으로 사용하고 실수 연산이 필요할 때 형 변환

sizeof 연산자는 피연산자의 크기를 바이트 단위로 알려 줌






